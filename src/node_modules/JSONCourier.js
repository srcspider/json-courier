var Promise = require('lie');
var oboe = require('oboe');
var _ = { merge: require('lodash.merge') };
// ----------------------------------------------------------------------------

// Private Static
// ==============

var _channels = {};
var _domainPrefix = '';

// Main Type
// =========

var JSONCourier = function (channel) {

	// allow object creation via function invokation
	if ( ! (this instanceof JSONCourier)) {
		return new JSONCourier(channel);
	}

	if ( _channels[channel]) {
		return _channels[channel];
	}
	else { // register new courier
		_channels[channel] = this;
	}

	this._channel = channel;
	this._urlroot = _domainPrefix.replace(/[\/]+$/, '') + '/' + channel.replace(/^[\/]+/, '');
	this._authToken = null;
};

JSONCourier.prototype = {

	authWith: function (authToken) {
		this._authToken = authToken;
		return this;
	},

	auth: function () {
		return this._authToken;
	},

	urldomain: function () {
		var regex = /^((?:[A-Z0-9]+:)?\/\/[^\/]+)(?:\/.*)?$/i;
		var matches = this._urlroot.match(regex);
		if (matches != null) {
			return matches[1];
		}
		else { // no domain
			return null;
		}
	},

	urlprefix: function () {
		var regex = /^(?:(?:[A-Z0-9]+:)?\/\/[^\/]+)(\/.*)$/i;
		var matches = this._urlroot.match(regex);
		if (matches != null) {
			return matches[1];
		}
		else { // no domain
			return '/';
		}
	},

	urlroot: function () {
		return this._urlroot;
	},

	prefixpath: function (path) {
		return this.urlprefix().replace(/[\/]+$/, '') + '/' + path.replace(/^[\/]+/, '');
	},

	fullpath: function (path) {
		return this._urlroot.replace(/[\/]+$/, '') + '/' + path.replace(/^[\/]+/, '');
	},

	req: function (endpoint, payload, accepts, options) {
		var self = this;

		var defaultOptions = {
			// empty
		};

		if (options == null) {
			options = defaultOptions;
		}
		else { // recieved options
			options = _.merge(defaultOptions, options);
		}

		if ( ! accepts) {
			accepts = [ 'success' ];
		}
		else if (accepts.indexOf('success') == -1) {
			accepts.push('success');
		}

		var requestBody = {
			auth: self.auth(),
			data: payload
		};

		return new Promise(function (resolve, reject) {

			var request = {
				url: self.fullpath(endpoint),
				method: 'POST',
				body: requestBody
			};

			oboe(request)
				.done(function (res) {
					if (res && ('status' in res) && ('data' in res)) {
						if (accepts.indexOf(res.status) != -1) {
							resolve(res);
						}
						else { // unacceptable
							reject(res);
						}
					}
					else { // invalid
						reject(new Error('Invalid response from ' + endpoint));
					}
				})
				.fail(function (err) {
					reject(new Error('Could not access ' + endpoint));
				});
		});
	},

	// functor version of req
	f: function (endpoint) {
		var self = this;
		return function (payload, accept) {
			return self.req(endpoint, payload, accept);
		};
	}

};

// Static Methods
// ==============

JSONCourier.domainPrefix = function (prefix) {
	if (prefix != null) {
		_domainPrefix = prefix;
	}
	else { // no prefix
		_domainPrefix = '';
	}
};

module.exports = JSONCourier;